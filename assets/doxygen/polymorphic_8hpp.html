<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>cereal: /home/shane/workspace/cereal/include/cereal/types/polymorphic.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cereal
   </div>
   <div id="projectbrief">A C++11 library for serialization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>cereal</span></a></li>
      <li><a href="index.html"><span>Doxygen&#160;Documentation</span></a></li>
      <li><a href="modules.html"><span>Code&#160;Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Source&#160;File&#160;Documentation</span></a></li>
      <li><a href="https://github.com/USCiLab/cereal"><span>Github</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d445d0c097210746bce3afd9a77bcad9.html">cereal</a></li><li class="navelem"><a class="el" href="dir_056182efa28390c8a7ef83cb1836ec86.html">types</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">polymorphic.hpp File Reference<div class="ingroups"><a class="el" href="group__OtherTypes.html">Miscellaneous Types Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for pointers to polymorphic base classes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="cereal_8hpp_source.html">cereal/cereal.hpp</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="memory_8hpp_source.html">cereal/types/memory.hpp</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="util_8hpp_source.html">cereal/details/util.hpp</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="helpers_8hpp_source.html">cereal/details/helpers.hpp</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="traits_8hpp_source.html">cereal/details/traits.hpp</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="polymorphic__impl_8hpp_source.html">cereal/details/polymorphic_impl.hpp</a>&gt;</code><br/>
</div>
<p><a href="polymorphic_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7b39ae2066f83f344e5a6881501fc022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b39ae2066f83f344e5a6881501fc022"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STATIC_CONSTEXPR</b>&#160;&#160;&#160;static constexpr</td></tr>
<tr class="separator:a7b39ae2066f83f344e5a6881501fc022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d7d9fc98f7a55a6f0031ea5eaea4e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polymorphic_8hpp.html#ae2d7d9fc98f7a55a6f0031ea5eaea4e6">CEREAL_REGISTER_TYPE</a>(T)</td></tr>
<tr class="memdesc:ae2d7d9fc98f7a55a6f0031ea5eaea4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a polymorphic type with cereal.  <a href="#ae2d7d9fc98f7a55a6f0031ea5eaea4e6">More...</a><br/></td></tr>
<tr class="separator:ae2d7d9fc98f7a55a6f0031ea5eaea4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84efbe4f256827ca26fe3d86d8bd528c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polymorphic_8hpp.html#a84efbe4f256827ca26fe3d86d8bd528c">CEREAL_REGISTER_TYPE_WITH_NAME</a>(T, Name)</td></tr>
<tr class="separator:a84efbe4f256827ca26fe3d86d8bd528c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fc708b2a6772ce3d05e026b7f25cfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polymorphic_8hpp.html#aa9fc708b2a6772ce3d05e026b7f25cfe">CEREAL_REGISTER_SHARED_LIBRARY</a>(LibName)</td></tr>
<tr class="separator:aa9fc708b2a6772ce3d05e026b7f25cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c30b6fd11b5d26a3556a6503b1cd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polymorphic_8hpp.html#a495c30b6fd11b5d26a3556a6503b1cd8">CEREAL_FORCE_LINK_SHARED_LIBRARY</a>(LibName)</td></tr>
<tr class="separator:a495c30b6fd11b5d26a3556a6503b1cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1ba6164125996cf35136a4309f966453"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ba6164125996cf35136a4309f966453"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a1ba6164125996cf35136a4309f966453"><td class="memTemplItemLeft" align="right" valign="top">typename::cereal::detail::InputBindingMap<br class="typebreak"/>
&lt; Archive &gt;::Serializers&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::polymorphic_detail::getInputBinding</b> (Archive &amp;ar, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a1ba6164125996cf35136a4309f966453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an input binding from the given archive by deserializing the type meta data. <br/></td></tr>
<tr class="separator:a1ba6164125996cf35136a4309f966453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d33747ce687e324440a360c1b8987b8"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a8d33747ce687e324440a360c1b8987b8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;(traits::is_default_constructible<br class="typebreak"/>
&lt; T &gt;::value||traits::has_load_and_construct<br class="typebreak"/>
&lt; T, Archive &gt;::value)&amp;&amp;!std::is_abstract<br class="typebreak"/>
&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::polymorphic_detail::serialize_wrapper</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a8d33747ce687e324440a360c1b8987b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <a href="#a8d33747ce687e324440a360c1b8987b8">More...</a><br/></td></tr>
<tr class="separator:a8d33747ce687e324440a360c1b8987b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e4b18c837d2487a4edcffe4c2a879"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a8c9e4b18c837d2487a4edcffe4c2a879"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;(traits::is_default_constructible<br class="typebreak"/>
&lt; T &gt;::value||traits::has_load_and_construct<br class="typebreak"/>
&lt; T, Archive &gt;::value)&amp;&amp;!std::is_abstract<br class="typebreak"/>
&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::polymorphic_detail::serialize_wrapper</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a8c9e4b18c837d2487a4edcffe4c2a879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <a href="#a8c9e4b18c837d2487a4edcffe4c2a879">More...</a><br/></td></tr>
<tr class="separator:a8c9e4b18c837d2487a4edcffe4c2a879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8faa1bd3d8119fcdb34b5b5453e6be"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a0e8faa1bd3d8119fcdb34b5b5453e6be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;(!traits::is_default_constructible<br class="typebreak"/>
&lt; T &gt;::value <br class="typebreak"/>
&amp;&amp;!traits::has_load_and_construct<br class="typebreak"/>
&lt; T, Archive &gt;::value)||std::is_abstract<br class="typebreak"/>
&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::polymorphic_detail::serialize_wrapper</b> (Archive &amp;, std::shared_ptr&lt; T &gt; &amp;, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a0e8faa1bd3d8119fcdb34b5b5453e6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <a href="#a0e8faa1bd3d8119fcdb34b5b5453e6be">More...</a><br/></td></tr>
<tr class="separator:a0e8faa1bd3d8119fcdb34b5b5453e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dac803441014030e0f686f535d72eeb"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a9dac803441014030e0f686f535d72eeb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;(!traits::is_default_constructible<br class="typebreak"/>
&lt; T &gt;::value <br class="typebreak"/>
&amp;&amp;!traits::has_load_and_construct<br class="typebreak"/>
&lt; T, Archive &gt;::value)||std::is_abstract<br class="typebreak"/>
&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::polymorphic_detail::serialize_wrapper</b> (Archive &amp;, std::unique_ptr&lt; T, D &gt; &amp;, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a9dac803441014030e0f686f535d72eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <a href="#a9dac803441014030e0f686f535d72eeb">More...</a><br/></td></tr>
<tr class="separator:a9dac803441014030e0f686f535d72eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759a15c02fad55311de9e5dd645a7319"><td class="memTemplParams" colspan="2"><a class="anchor" id="a759a15c02fad55311de9e5dd645a7319"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a759a15c02fad55311de9e5dd645a7319"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value &amp;&amp;std::is_abstract&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a759a15c02fad55311de9e5dd645a7319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, abstract. <br/></td></tr>
<tr class="separator:a759a15c02fad55311de9e5dd645a7319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e1ce1157644fad605ade652112daf1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa6e1ce1157644fad605ade652112daf1"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa6e1ce1157644fad605ade652112daf1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value &amp;&amp;!std::is_abstract&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:aa6e1ce1157644fad605ade652112daf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, not abstract. <br/></td></tr>
<tr class="separator:aa6e1ce1157644fad605ade652112daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162562abb32a0be716dbfb98f1a31a33"><td class="memTemplParams" colspan="2"><a class="anchor" id="a162562abb32a0be716dbfb98f1a31a33"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a162562abb32a0be716dbfb98f1a31a33"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a162562abb32a0be716dbfb98f1a31a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr for polymorphic types. <br/></td></tr>
<tr class="separator:a162562abb32a0be716dbfb98f1a31a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fd3494d3937e25e00c63e3822e8037"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0fd3494d3937e25e00c63e3822e8037"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:af0fd3494d3937e25e00c63e3822e8037"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:af0fd3494d3937e25e00c63e3822e8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for polymorphic types. <br/></td></tr>
<tr class="separator:af0fd3494d3937e25e00c63e3822e8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cbd30aefc13f4a54094593603db13c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0cbd30aefc13f4a54094593603db13c"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa0cbd30aefc13f4a54094593603db13c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:aa0cbd30aefc13f4a54094593603db13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for polymorphic types. <br/></td></tr>
<tr class="separator:aa0cbd30aefc13f4a54094593603db13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7690f06f7ad55613cec7ae757b1750"><td class="memTemplParams" colspan="2"><a class="anchor" id="aba7690f06f7ad55613cec7ae757b1750"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:aba7690f06f7ad55613cec7ae757b1750"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value &amp;&amp;std::is_abstract&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:aba7690f06f7ad55613cec7ae757b1750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types that are abstract. <br/></td></tr>
<tr class="separator:aba7690f06f7ad55613cec7ae757b1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7296078465310c1af67d5674d7258c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7296078465310c1af67d5674d7258c2"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ab7296078465310c1af67d5674d7258c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value &amp;&amp;!std::is_abstract&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ab7296078465310c1af67d5674d7258c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types, not abstract. <br/></td></tr>
<tr class="separator:ab7296078465310c1af67d5674d7258c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d1d69a4d25ed7715c105b14ed6f8957"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_polymorphic&lt; T &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cereal::CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types. <br/></td></tr>
<tr class="separator:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support for pointers to polymorphic base classes. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a495c30b6fd11b5d26a3556a6503b1cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_FORCE_LINK_SHARED_LIBRARY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LibName</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>cereal {                                    \</div>
<div class="line">  namespace detail {                                    \</div>
<div class="line">    void load_library_dummy_##LibName();                \</div>
<div class="line">  } <span class="comment">/* end detail */</span>                                    \</div>
<div class="line">  namespace load_dummy {                                \</div>
<div class="line">    void load_library_##LibName()                       \</div>
<div class="line">    {                                                   \</div>
<div class="line">      ::cereal::detail::load_library_dummy_##LibName(); \</div>
<div class="line">    }                                                   \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span></div>
</div><!-- fragment --><p>Forces the linker to link a previously registered (with cereal) shared library</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="polymorphic_8hpp.html#aa9fc708b2a6772ce3d05e026b7f25cfe">CEREAL_REGISTER_SHARED_LIBRARY</a></dd></dl>
<p>This should be placed in your executable source. </p>

</div>
</div>
<a class="anchor" id="aa9fc708b2a6772ce3d05e026b7f25cfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_SHARED_LIBRARY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LibName</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>cereal {                            \</div>
<div class="line">  namespace detail {                            \</div>
<div class="line">    void load_library_dummy_##LibName() {}      \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span></div>
</div><!-- fragment --><p>Adds a way to force loading of a shared library containing only calls to CEREAL_REGISTER_TYPE</p>
<p>Since CEREAL_REGISTER_TYPE must be in a source file, it is possible for the linker to never load a shared library containing only these registrations as they are never explicitly referenced. This macro, in combination with CEREAL_FORCE_LINK_SHARED_LIBRARY, prevents this link from being optimized away. This is only necessary if you never explicitly reference any code implemented in your shared library (header files do not count).</p>
<p>This must be placed in a single source file of your shared library.</p>
<p>LibName can be any unique name of your choosing. </p>

</div>
</div>
<a class="anchor" id="ae2d7d9fc98f7a55a6f0031ea5eaea4e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>cereal {                                    \</div>
<div class="line">  namespace detail {                                    \</div>
<div class="line">  template &lt;&gt;                                           \</div>
<div class="line">  struct binding_name&lt;T&gt;                                \</div>
<div class="line">  {                                                     \</div>
<div class="line">    STATIC_CONSTEXPR <span class="keywordtype">char</span> <span class="keyword">const</span> * name() { <span class="keywordflow">return</span> #T; } \</div>
<div class="line">  };                                                    \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span>                              <a class="code" href="polymorphic__impl_8hpp.html#a7632998cb974459cfc3f9969da8485d5">\</a></div>
<div class="line"><a class="code" href="polymorphic__impl_8hpp.html#a7632998cb974459cfc3f9969da8485d5">  CEREAL_BIND_TO_ARCHIVES</a>(T)</div>
<div class="ttc" id="polymorphic__impl_8hpp_html_a7632998cb974459cfc3f9969da8485d5"><div class="ttname"><a href="polymorphic__impl_8hpp.html#a7632998cb974459cfc3f9969da8485d5">CEREAL_BIND_TO_ARCHIVES</a></div><div class="ttdeci">#define CEREAL_BIND_TO_ARCHIVES(T)</div><div class="ttdoc">Binds a polymorhic type to all registered archives. </div><div class="ttdef"><b>Definition:</b> polymorphic_impl.hpp:59</div></div>
</div><!-- fragment -->
<p>Registers a polymorphic type with cereal. </p>
<p>Polymorphic types must be registered before pointers to them can be serialized. This also assumes that all relevent archives have also previously been registered. Registration for archives is usually done in the header file in which they are defined. This means that type registration needs to happen after specific archives to be used are included.</p>
<p>Registering a type lets cereal know how to properly serialize it when a pointer to a base object is used in conjunction with a derived class.</p>
<p>Polymorphic support in cereal requires RTTI to be enabled </p>

</div>
</div>
<a class="anchor" id="a84efbe4f256827ca26fe3d86d8bd528c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_TYPE_WITH_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>cereal {                                         \</div>
<div class="line">  namespace detail {                                         \</div>
<div class="line">  template &lt;&gt;                                                \</div>
<div class="line">  struct binding_name&lt;T&gt;                                     \</div>
<div class="line">  { STATIC_CONSTEXPR <span class="keywordtype">char</span> <span class="keyword">const</span> * name() { <span class="keywordflow">return</span> Name; } }; \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span>                                   <a class="code" href="polymorphic__impl_8hpp.html#a7632998cb974459cfc3f9969da8485d5">\</a></div>
<div class="line"><a class="code" href="polymorphic__impl_8hpp.html#a7632998cb974459cfc3f9969da8485d5">  CEREAL_BIND_TO_ARCHIVES</a>(T)</div>
<div class="ttc" id="polymorphic__impl_8hpp_html_a7632998cb974459cfc3f9969da8485d5"><div class="ttname"><a href="polymorphic__impl_8hpp.html#a7632998cb974459cfc3f9969da8485d5">CEREAL_BIND_TO_ARCHIVES</a></div><div class="ttdeci">#define CEREAL_BIND_TO_ARCHIVES(T)</div><div class="ttdoc">Binds a polymorhic type to all registered archives. </div><div class="ttdef"><b>Definition:</b> polymorphic_impl.hpp:59</div></div>
</div><!-- fragment --><p>Registers a polymorphic type with cereal, giving it a user defined name</p>
<p>In some cases the default name used with CEREAL_REGISTER_TYPE (the name of the type) may not be suitable. This macro allows any name to be associated with the type. The name should be unique </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2014 10:36:09 for cereal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42360142-1', 'uscilab.github.io');
  ga('send', 'pageview');
</script>
</body>
</html>
